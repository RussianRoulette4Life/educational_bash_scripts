# Все исполняемые скрипты начинаются с шебанга. 
# Он говорит, какая программа будет исполнять скрипт.
# В данном случае это bash

#!/usr/bin/env bash

# Таким образом задаётся значение переменной.
# Можно задавать с кавычками, можно без, но рекомендуется их использовать.

VARIABLE_1=значение1

VARIABLE_2="value2"

# Для получения значения переменной перед её именем ставится "$"

ultimate_var="$VARIABLE_1 и $VARIABLE_2"
echo $ultimate_var

# Значение переменной можно удалить

unset ultimate_var
unset VARIABLE_1
unset VARIABLE_2

# Можно одновременно создавать переменные и экспортировать их

export RANDOM_DATA="ну типа рандом!"


# Один скрипт может вызывать другой.

source /etc/bash.bashrc

# Далее: парочка if

if [ -f 2nd.sh ]; then
	source 2nd.sh "$RANDOM_DATA"
else
	echo "2nd.sh не существует!"
fi

if [[ $PATH == *"/usr/bin"* ]]; then
	echo "Внутри PATH существует /usr/bin"
	whoami
else
	echo "а... как у вас программы запускаются??"
	whoami
fi

if [[ $((10+4)) == "14" && $((1/2)) == 0 ]]; then
	echo "bash умеет совершать простые математические операции! Но только над целыми числами"
	pwd
fi
## переменная окружения $0 отличается, в зависимости от того, как был запущен файл.
## Если файл был исполнен, как отдельный скрипт (./1st.sh или bash 1st.sh), то
## скрипт исполняет отдельный процесс bash, не тот, который запущен у вас в терминале.
## Из этого следует, что $0 будет показывать путь к файлу при его отдельном исполнении,
## или же /usr/bin/bash при его source или ".", потому будьте внимательны!
## Обычно это проблемой не является, потому что скрипты напрямую пишуться так, чтобы
## быть либо "сорснутыми", либо исполненными отдельно, но этот - исключение. 
script_dir="$(dirname $0)"
abs_script_path="$(realpath $script_dir)/1st.sh"

## настоятельно рекомендую посмотреть 2nd.sh перед продолжением
# Теперь for (+ приколы с цветами)

echo -e "Также, тяжко в это поверить, но в терминалы \e[33mМОЖНО ВЫВОДИТЬ ЦВЕТА!\e[0m С помощью ansi escape кодов.\e[35m"

for i in $(seq 1 100); do
	echo -n "Привет, $i! "
done

echo -en "\e[0m"

for ELEMENT in $(ls /etc); do
	if [[ -f /etc/$ELEMENT ]]; then
		echo -n "/etc/$ELEMENT - файл; "
	else
		echo -n "/etc/$ELEMENT - каталог; "
	fi
done
echo -en "\n"

## В данном случае 2> /dev/null перенаправляет все ошибки (по типу доступ запрещён) на /dev/null, то есть вникуда.

for file in `find /etc -type f 2> /dev/null`; do
	if [[ -n $(grep -E "$USER" $file 2> /dev/null ) ]]; then
		echo "$file упомянает вас, $USER."
	fi
done

# Далее - case

case $1 in
	"")
		echo "В программу ничего не было подано как аргумент"
		;;
	"help")
		echo "Нужна помощь? ну не знаю зайди в интернет что ле"
		;;
	*)
		echo "Аргумент: $1"
		;;
esac

# По мелочи: перенапрявления вывода, "конвейер" и пр.
OUTPUT_FILE="$script_dir/echoes.txt"
echo "Буду записывать в $OUTPUT_FILE, $0, $BASH_SOURCE"
## sleep - останавливает исполнение программы на n секунд. Как delay в ардуинке
sleep 5
grep -n -E "echo" "$script_dir/1st.sh" > $OUTPUT_FILE
echo -e "Содержание \e[3mechoes.txt\e[0m: " && cat "$script_dir/echoes.txt"
rm "$scrip_dir/echoes.txt"
## alias - создаёт псевдоним для команды или целого списка команд. Применится к вашему терминалу
## только после ". 1st.sh" или "source 1st.sh", обычно исполнение не сработает
alias run_1st_again=". $abs_script_path"

